
//top module program block for mesh based systolic array:
module top(cs,clk,rst,in1,in2,in3,in4,y);
input [7:0]in1,in2,in3,in4;
input cs,clk,rst;
output reg [7:0]y;
reg [7:0] i1,i2;
wire [7:0] v33,v23,v13,v,h31,h32,h33,h34,h35,h21,h22,h23,h24,h25,h11,h12,h13,h14,h15,w33,w32,w31,w23,w22,w21,w13,w12,w11,y33,y32,y31,y23,y22,y21,y13,y12,y11;
parameter[7:0] pre_out = 8'b00000000;
parameter[7:0] b11 = 8'b00100000;
parameter[7:0] b12 = 8'b00000000;
parameter[7:0] b13 = 8'b01001000;
parameter[7:0] b21 = 8'b00000010;
parameter[7:0] b22 = 8'b00100001;
parameter[7:0] b23 = 8'b00000000;
parameter[7:0] b31 = 8'b01010010;
parameter[7:0] b32 = 8'b01000110;
parameter[7:0] b33 = 8'b00110110;


vertical_buff vf(clk,rst,in1,in2,in3,in4,v33,v23,v13,v);
h_buff hf(clk,v,h31,h32,h33,h34,h35);//hf

mux1 m1(cs,h33,v33,w33);
pe_proposed pe1(clk,rst,w33,b11,pre_out,y33);

mux1 m2(cs,h34,y33,w32);
pe_proposed pe2(clk,rst,w32,b12,y33,y32);

mux1 m3(cs,h35,y32,w31);
pe_proposed pe3(clk,rst,w31,b13,y32,y31);

always @(y31)begin
i1 = y31;
end
h_buff hf1(clk,i1,h21,h22,h23,h24,h25);//hf1

mux1 m4(cs,h23,v23,w23);
pe_proposed pe4(clk,rst,w23,b21,pre_out,y23);

mux1 m5(cs,h22,y23,w22);
pe_proposed pe5(clk,rst,w22,b22,y23,y22);

mux1 m6(cs,h21,y22,w21);
pe_proposed pe6(clk,rst,w21,b23,y22,y21);

always @(y21)begin
i2=y21;
end
h_buff hf2(clk,i2,h11,h12,h13,h14,h15);//hf2

mux1 m7(cs,h13,v13,w13);
pe_proposed pe7(clk,rst,w13,b31,pre_out,y13);

mux1 m8(cs,h12,y13,w12);
pe_proposed pe8(clk,rst,w12,b32,y13,y12);

mux1 m9(cs,h11,y12,w11);
pe_proposed pe9(clk,rst,w11,b33,y12,y11);

always @(y11 or y21 or y31)begin
y = y11+y21+y31;
end

endmodule

-----------------------------------------------------------------------------


//vertical buffer program block:

module vertical_buff(clk,rst,i1,i2,i3,i4,w1,w2,w3,w4);
input clk,rst;
input [7:0]i1,i2,i3,i4;
output reg [7:0]w1,w2,w3,w4;
always @(posedge clk)begin
if(!rst)begin
w1 = 0;
w2 = 0;
w3 = 0;
w4 = 0;
end
else begin
w1 = i1;
w2 = i2;
w3 = i3;
w4 = i4;
end
end
endmodule


--------------------------------------------------------------------


//horizontal buffer program block:

module h_buff(clk,in,y1,y2,y3,y4,y5);
 input [7:0] in;
 input clk;
 reg [7:0]w[4:0];
 output reg[7:0]y1,y2,y3,y4,y5;
 initial begin
 w[0]=8'h00;
 w[1]=8'h00;
 w[2]=8'h00;
 w[3]=8'h00;
 w[4]=8'h00;
 end
 always @ (posedge clk)
begin
w[4]<=in;
w[3]<=w[4];
w[2]<=w[3];
w[1]<=w[2];
w[0]<=w[1];
end
always @(w[4] or w[3] or w[2] or w[1] or w[0])begin
y1 = w[4];
y2 = w[3];
y3= w[2];
y4 = w[1];
y5 = w[0];
end
endmodule



-----------------------------------------------------------------------------------
//single processing element programe block

module pe_proposed(clk,rst,in,b,pre_out,y);

input [7:0]in,b;
input clk,rst;
wire [1:0]c;
input [7:0] pre_out;
wire [7:0]x0,y0,x2;
reg z;
reg [7:0]m3,bs1,bs2,m2,x1,y1,xi,yi,out;
output reg[7:0]y;
//counter c0(clk,rst,c);//counter module calling
//mod27c c1(clk,rst,out1);//mod 27 counter

 assign x0=(b[7])?0:in;//m7
 assign y0=(b[7])?(~in+1):0;//m6

 always @(posedge clk)begin
 if(!rst)begin
 xi <=0;
 yi <=0;
end
 
 else if(c==0)begin
 xi <= x0; 
 yi <= y0;
end 
 else if(c==2'b01 || c==2'b11)begin
 xi <=x1;
 yi <=y1;
 end
 end
counter c0(clk,rst,c);//counter module calling

always @(xi or c)//bs1
	begin
		if (c ==2'b00)
			bs1<=xi;
		else if(c == 2'b01)
			bs1<={1'b0,xi[7:1]};
			else if(c == 2'b11)
			bs1<={3'b000,xi[7:3]};
			end
			
always @(yi or c)//bs2
  begin
	if (c==2'b00 || c==2'b10)
		bs2<=yi;
	else if(c==2'b01)
		bs2<={1'b0,yi[7:1]};
		else if(c==2'b11)
		bs2<={3'b000,yi[7:3]};
		
		end
		
always@(c or b)//m1 mux and inbilut nand gate
	begin
	if(c==2'b00)
	z <= ~(b[0] & b[1]);
	else if(c==2'b01)
	z <= ~(b[2] & b[3]);
	else if(c==2'b11)
	z <= ~(b[4] & b[5]);
	end
	
	always @(bs1 or z)//m3 mux
	begin
	if(z) 
	m3 = bs1>>1;
	else
	m3 = bs1;
	end

always @(bs2 or z)//m2 mux
begin
	if(z) 
	m2=bs2>>1;
	else
	m2=bs2;
	end

	always @(m2 or x0 or z) //a2 adder 
	  begin  
		 if (z==1'b0)
		 x1 = (m2+x0);		 //
		 else           
		 x1 = (m2-x0);
	 end  
	assign x2=x1>>1;  
	always @(m3 or y0 or z)  
	  begin  
		 if (z==1'b0) y1 = m3+y0;  //a1 adder
		 else           y1 = m3-y0;  
		end
		
always @(x2 or y1 or b[6])//m4 mux
	begin
		if(b[6]) 
		out=(x2+y1);
		else
		out = y1;
	end
	
always @( out or pre_out)begin 

y <= out + pre_out;
end

endmodule

----------------------------------------------------------------------------
//counter module program:

module counter(input clk, rst, output reg[1:0]c);
always @ (posedge clk)begin
if(!rst)
c<=2'b00;
else if
(c==2'b00)
c<=c+1;
else if(c==2'b01)
c<=c+2;
else if(c==2'b11)
c<=2'b00;
end
endmodule


